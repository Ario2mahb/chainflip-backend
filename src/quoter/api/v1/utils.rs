use crate::common::{api::ResponseError, coins::Coin};
use rand::Rng;
use reqwest::StatusCode;
use std::{
    collections::{BTreeSet, HashMap},
    sync::{Arc, Mutex},
};

/// Generate a uniqe input address id and insert it into the cache
pub fn generate_unique_input_address_id<R: Rng>(
    input_coin: Coin,
    input_id_cache: Arc<Mutex<HashMap<Coin, BTreeSet<String>>>>,
    rng: &mut R,
) -> Result<String, ResponseError> {
    let mut cache = input_id_cache.lock().unwrap();
    let used_ids = cache.entry(input_coin).or_insert(BTreeSet::new());

    // We can test this by passing a SeededRng
    let input_address_id = loop {
        let id = match input_coin {
            Coin::BTC => rng.gen_range(5, u32::MAX).to_string(),
            Coin::ETH => rng.gen_range(5, u32::MAX).to_string(),
            Coin::LOKI => {
                let random_bytes = rng.gen::<[u8; 8]>();
                hex::encode(random_bytes)
            }
            _ => {
                return Err(ResponseError::new(
                    StatusCode::BAD_REQUEST,
                    "Invalid input id",
                ))
            }
        };

        if !used_ids.contains(&id) {
            break id;
        }
    };

    // Add the id in the cache
    used_ids.insert(input_address_id.clone());

    Ok(input_address_id)
}

#[cfg(test)]
mod test {
    use rand::{prelude::StdRng, SeedableRng};

    use super::*;

    fn cache() -> HashMap<Coin, BTreeSet<String>> {
        let mut cache: HashMap<Coin, BTreeSet<String>> = HashMap::new();
        cache.insert(Coin::LOKI, BTreeSet::new());
        cache.insert(Coin::ETH, BTreeSet::new());
        cache.insert(Coin::BTC, BTreeSet::new());
        cache
    }

    #[test]
    fn generates_id_and_inserts_to_cache() {
        let mut rng = StdRng::seed_from_u64(0);
        let cache = cache();
        let cache = Arc::new(Mutex::new(cache));

        for coin in vec![Coin::LOKI, Coin::ETH, Coin::BTC] {
            generate_unique_input_address_id(coin, cache.clone(), &mut rng)
                .expect(&format!("Expected to generate unique id for {}", coin));
            assert_eq!(cache.lock().unwrap().get(&coin).unwrap().len(), 1);
        }
    }

    #[test]
    fn generates_unique_ids() {
        let mut cache = cache();

        // The first ids generated by the rng with seed 0
        cache
            .get_mut(&Coin::ETH)
            .unwrap()
            .insert("449479075714955191".to_string());

        cache
            .get_mut(&Coin::BTC)
            .unwrap()
            .insert("449479075714955191".to_string());

        cache
            .get_mut(&Coin::LOKI)
            .unwrap()
            .insert("b2d6a87ec06934ff".to_string());

        let cache = Arc::new(Mutex::new(cache));
        for coin in vec![Coin::LOKI, Coin::ETH, Coin::BTC] {
            let mut rng = StdRng::seed_from_u64(0);
            generate_unique_input_address_id(coin, cache.clone(), &mut rng)
                .expect(&format!("Expected to generate unique id for {}", coin));
            assert_eq!(cache.lock().unwrap().get(&coin).unwrap().len(), 2);
        }
    }
}
